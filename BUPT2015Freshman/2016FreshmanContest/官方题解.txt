由于负责人准备不周， 密码更改后未保存， 以至于重置了一遍密码， 耽搁了比赛时间， 在此向参加比赛的同学道歉。
A、  二进制加法，  因为位数只有30位， 所以比较方便的写法是转成int后相加再加回来，     有部分对二进制可能还不太熟悉， 有出现搞反了高地位的情况。
     另外，由于数据格式问题， 字符行末有多余的\r字符， 使用getchar()或者scanf("%c", &x)的同学会WA掉。 
B、  求函数最大值， 求导后解出极值点即可。 如果仔细推导一下可以发现最大值点一定会出现在整数格点上， 所以最简单的办法， 枚举x从a到b即可。

C、矩阵乘法。

D、枚举2~9每一个数字的阶乘最多可以拆成哪几个数字的阶乘， 然后把大的数字排在前面。
   如9! = 7! * 3! * 3! * 2!

E、可以二分至少需要导进去的水的高度， 然后简单算一下折射角就可以了。 没学过二分的同学可以通过列方程， 设水高度为h， 
(y[e] - h)/EP = u * sqrt(1 - (h/CP)^2)
d = sqrt(EP^2 - （H－h）^2)
CP = sqrt((x[e] - d- x)^2 + h^2)
(y[e] - h)/(H - h) = d / (W - x[e] + d)
4个方程， 未知数为EP, CP, h, d, 所以是可解的
F、  显然对于r相同的位置来说， l值越小， F函数值越大， 那么我们可以设dp[i][j]为
S[1, i] 和 T[1, j]的最长公共后缀， dp[i][j] = (S[i] == T[j]? dp[i-1][j-1] + 1 : 0)  复杂度为O(n^2)

G、 假设当前开始放第i个碗， 显然前面i-1个碗将组成一个凸包，  这个碗进去将形成新的凸包， 那么把他盖住的那些碗从凸包的栈中弹出来即可。 复杂度为O(n)
    当然也可以暴力地O(n^2), 显然第i个碗的位置即把他分别重叠在前i-1个碗上的位置上的最高的那个位置。

H、 假如saber已经到达了第i个加油站， 那么如果saber此时剩余的不能到达第i＋1个， 那么她一定要在前i个点中尽可能地多加油， 所以用一个优先队列（大根堆）维护前i个加油站中尚未用掉的加油机会， 然后不停地取最大的出来， 如果去完了仍然不能达到， 那么就输出－1.

I、 将值按从大到小的顺序插入自己原来的位置中， 那么当插入位置为i的数时， 假设i左右两端联通块的范围是[l, r], 那么显然对于[l, r]中任意跨i的子区间都以A[i]为最小值， 且此时其它联通块的所有子区间的最小值都大于等于A[i], 所以维护全局子区间个数即可。
注意加上[l, r]自身子区间中的偏序关系的贡献。


